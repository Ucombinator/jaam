import java.util.*;
import java.io.IOException;

/**
 * TODO: Information re: ExceptionLoop
 *
 * Certain try/catch/finally blocks appear to the JVM as loops. Examples can be found in the JAAM project's
 * examples/loops/ident/ExceptionLoops.java file.
 *
 * A decompilation of the bytecode around the `nestless()` function in that file reveals the following exception
 * table:
 *
 *   Exception table:
 *   from    to  target type
 *       0    14    25   Class java/lang/RuntimeException
 *       0    14    45   any
 *      25    34    45   any
 *      45    47    45   any
 *
 * We can see that the final exception starts at instruction 45 and targets the same instruction. Loop analysis by
 * Soot identifies this structure as a loop (which is reasonable, because... it is a loop).
 *
 * It appears that the number of variables in the function plays some role in the creation of the loop. Removing any
 * of the variables results in the following exception table:
 *
 *   Exception table:
 *   from    to  target type
 *       0    12    23   Class java/lang/RuntimeException
 *       0    12    43   any
 *      23    32    43   any
 *
 * There is no loop in this exception table.
 *
 * Nesting a try/catch block inside the `finally` portion of a try/catch/finally block induces the behavior regardless
 * of the number of variables present. Consider * `nestedOne()`, which has the following exception table:
 *
 *   Exception table:
 *   from    to  target type
 *       7    12    15   Class java/lang/RuntimeException
 *       2     7    21   Class java/lang/RuntimeException
 *      26    31    34   Class java/lang/RuntimeException
 *       2     7    40   any
 *      21    26    40   any
 *      42    47    50   Class java/lang/RuntimeException
 *      40    42    40   any
 *
 * The final line reveals the same type of loop structure as before.
 *
 * If the nested try/catch also gets a `finally` block, the exception table produces *multiple* loops:
 *
 *   Exception table:
 *   from    to  target type
 *       7    12    17   Class java/lang/RuntimeException
 *       7    12    26   any
 *      17    22    26   any
 *      26    28    26   any
 *       2     7    36   Class java/lang/RuntimeException
 *      41    46    51   Class java/lang/RuntimeException
 *      41    46    63   any
 *      51    58    63   any
 *      63    65    63   any
 *       2     7    72   any
 *      36    41    72   any
 *      74    79    84   Class java/lang/RuntimeException
 *      74    79    96   any
 *      84    91    96   any
 *      96    98    96   any
 *      72    74    72   any
 *
 * There are loops in the handling of the exceptions starting at instructions 63, 96, and 72.
 *
 * I have included a filter to remove these loops from our analyses, as they are not helpful. The loops are filtered in
 * the `getLoopInfoSet` method of org.ucombinator.jaam.util.Loop, which is called in the `getLoopForest` method of
 * org.ucombinator.jaam.tools.Loop3.
 *
 * As far as we can tell, the loop is generated by the switch from instruction `astore_3` to `astore 4` (no typo). When
 * `astore 4` is used, we see the loop-generation behavior. (This is why the number of variables present in the method
 * play a role.)
 */

class ExceptionLoops {
    public static void main(String[] args) {}

    public static void throwException() throws RuntimeException {
        throw new RuntimeException();
    }

    public void nestless() {
        try {
            int i = 0;
            int i2 = 0;
            int i3 = 0;
            System.out.println("try");
        }
        catch (RuntimeException ex) {
            System.out.println("catch");
        }
        finally {
            System.out.println("finally");
        }

        return;
    }

    public int nestedOne() {
        int val = 0;

        try {
            val = 1;
            throwException();
        }
        catch (RuntimeException ex) {
            val = 2;
            return val;
        }
        finally {
            try {
                val = 3;
                throwException();
            }
            catch (RuntimeException ex2) {
                val = 4;
            }
        }

        return val;
    }

    public int nestedTwo() {
        int val = 0;

        try {
            val = 1;
            throwException();
        }
        catch (RuntimeException ex) {
            val = 2;
            return val;
        }
        finally {
            try {
                val = 3;
                throwException();
            }
            catch (RuntimeException ex2) {
                val = 4;
                return val;
            }
            finally {
                val = 5;
            }
        }

        return val;
    }
}